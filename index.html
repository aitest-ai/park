<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>å¤¢å¹»éŠæ¨‚åœ’ (ç²¾æº–æŒ‰éˆ•ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Microsoft JhengHei', sans-serif; background-color: #87CEEB; user-select: none; -webkit-user-select: none; }
        
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            color: #555;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 2000; transition: opacity 0.8s ease-out;
        }
        h1 { font-weight: 900; letter-spacing: 5px; margin: 0; text-shadow: 2px 2px 0px #fff; font-size: 3.5em; color: #ff6b6b; }
        .subtitle { letter-spacing: 3px; font-size: 1.2em; margin-top: 15px; text-transform: uppercase; color: #777; }
        
        #start-btn {
            background: #fff; color: #ff6b6b; border: 2px solid #ff6b6b; padding: 15px 60px;
            font-size: 18px; font-weight: bold; cursor: pointer; margin-top: 50px;
            border-radius: 50px; transition: all 0.3s; box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }
        #start-btn:hover { background: #ff6b6b; color: #fff; transform: translateY(-2px); }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* [ä¿®æ”¹] æŒ‰éˆ•æ¨£å¼ï¼šæ›´åƒä¸€å€‹å¯é»æ“Šçš„æŒ‰éˆ• */
        #interaction-btn {
            position: absolute; top: 0; left: 0;
            transform: translate(-50%, -50%); 
            background: #FFD700; color: #333; padding: 10px 25px;
            font-size: 16px; border-radius: 50px; font-weight: bold;
            display: none; 
            pointer-events: auto; /* é—œéµï¼šè®“æŒ‰éˆ•å¯ä»¥è¢«æ»‘é¼ é»æ“Š */
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            border: 3px solid #fff;
            white-space: nowrap;
            z-index: 100;
            transition: transform 0.1s, opacity 0.2s;
        }
        #interaction-btn:hover { transform: translate(-50%, -50%) scale(1.1); background: #FFC107; }
        #interaction-btn:active { transform: translate(-50%, -50%) scale(0.95); }

        #status {
            position: absolute; top: 20px; left: 20px;
            color: #fff; font-size: 14px; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            display: none; font-weight: bold; background: rgba(0,0,0,0.1); padding: 5px 10px; border-radius: 15px;
        }

        #controls-hint {
            position: absolute; bottom: 20px; right: 20px;
            color: rgba(255,255,255,0.9); font-size: 12px; text-align: right;
            background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; pointer-events: none;
        }

        #joystick-zone {
            position: absolute; bottom: 40px; left: 30px; width: 120px; height: 120px;
            background: rgba(255,255,255,0.2); border-radius: 50%; border: 2px solid rgba(255,255,255,0.5);
            pointer-events: auto; touch-action: none; display: none; backdrop-filter: blur(4px);
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: #fff; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        #look-zone {
            position: absolute; top: 0; right: 0; width: 50%; height: 100%;
            pointer-events: auto; touch-action: none; display: none;
        }

        #upload-input { display: none; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>DREAMLAND</h1>
        <p class="subtitle">ç²¾æº–æŒ‰éˆ•ç‰ˆ</p>
        <button id="start-btn">é–‹å§‹å‰µä½œ</button>
    </div>

    <div id="ui-layer">
        <div id="status">â— æº–å‚™å°±ç·’</div>
        <div id="interaction-btn">âœ¨ é»æ­¤äº’å‹•</div>
        
        <div id="controls-hint">
            <b>æ“ä½œèªªæ˜</b><br>
            ç§»å‹•ï¼šWASD æˆ– æ–¹å‘éµ<br>
            è¦–è§’ï¼šæŒ‰ä½æ»‘é¼ å·¦éµæ‹–æ›³<br>
            äº’å‹•ï¼šæ»‘é¼ ç§»åˆ°ç‰©ä»¶ -> é»æ“Šé»ƒè‰²æŒ‰éˆ•
        </div>
    </div>

    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    <div id="look-zone"></div>
    <input type="file" id="upload-input" accept="image/*">

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Config
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'amusement-park-floating-btn';
        let firebaseConfig;
        if (typeof __firebase_config !== 'undefined') {
            firebaseConfig = JSON.parse(__firebase_config);
        } else {
            // [GitHub Pages]
            firebaseConfig = {
                apiKey: "AIzaSyCuA_Qb-pRaM0vE0-waF2Ck2aBSgq9zB2Y",
                authDomain: "park-de7a6.firebaseapp.com",
                projectId: "park-de7a6",
                storageBucket: "park-de7a6.firebasestorage.app",
                messagingSenderId: "557277383172",
                appId: "1:557277383172:web:2dabb044dd651541430351",
                measurementId: "G-CD0ESBXH0Y"
            };
        }

        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch(e) { console.warn("Offline Mode"); }

        let currentUser = null;
        let myColor = new THREE.Color().setHSL(Math.random(), 0.8, 0.5).getHexString();
        let isRunning = false;

        // Keys
        const keys = { w: false, a: false, s: false, d: false, arrowup: false, arrowdown: false, arrowleft: false, arrowright: false };

        // UI Refs
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('start-btn');
        const statusEl = document.getElementById('status');
        const btnEl = document.getElementById('interaction-btn');
        const uploadInput = document.getElementById('upload-input');
        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        const lookZone = document.getElementById('look-zone');

        // Textures
        function createGrassTex() {
            const s=512; const c=document.createElement('canvas'); c.width=s; c.height=s;
            const ctx=c.getContext('2d');
            ctx.fillStyle='#66bb6a'; ctx.fillRect(0,0,s,s); 
            for(let i=0;i<20000;i++){
                ctx.fillStyle = Math.random()>0.5 ? '#81c784' : '#4caf50';
                ctx.fillRect(Math.random()*s,Math.random()*s,2,2);
            }
            const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(40,40);
            t.colorSpace = THREE.SRGBColorSpace; return t;
        }
        function createWallTex() {
            const s=256; const c=document.createElement('canvas'); c.width=s; c.height=s;
            const ctx=c.getContext('2d');
            ctx.fillStyle='#f5f5f5'; ctx.fillRect(0,0,s,s);
            ctx.fillStyle='#e0e0e0';
            for(let i=0; i<10; i++) { ctx.fillRect(0, i*25.6, s, 2); ctx.fillRect(i*25.6, 0, 2, s); }
            const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(10,10);
            t.colorSpace = THREE.SRGBColorSpace; return t;
        }

        startBtn.addEventListener('click', async () => {
            startScreen.style.opacity = 0;
            setTimeout(() => startScreen.style.display='none', 600);
            statusEl.style.display='block';
            joystickZone.style.display='block';
            lookZone.style.display='block';
            if(!isRunning) { init3D(); isRunning = true; initAuth(); }
        });

        function isMobile() { return /Android|iPhone|iPad/i.test(navigator.userAgent); }
        async function initAuth() {
            if(!auth) return;
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) await signInWithCustomToken(auth, __initial_auth_token);
                else await signInAnonymously(auth);
            } catch(e){}
        }
        if(auth) onAuthStateChanged(auth, u => { if(u) { currentUser=u; statusEl.innerText="â— ç·šä¸Šè¨­è¨ˆä¸­"; startNetworkSync(); } });

        // 3D
        let scene, camera, renderer;
        let interactables = [];
        let buttons = [];
        let colliders = [];
        let raycaster;
        // targetObj: ç›®å‰ã€Œå¯èƒ½ã€è¢«é¸ä¸­çš„ç‰©ä»¶
        let targetObj = null;
        let moveVector = new THREE.Vector3();
        let lookEuler = new THREE.Euler(0,0,0,'YXZ');
        let joystickActive=false, lookActive=false, lastLookX=0, lastLookY=0;
        let isDragging = false;
        
        // [æ–°å¢] åˆ¤æ–·æ»‘é¼ æ˜¯å¦æ­£åœ¨æŒ‰éˆ•ä¸Š
        let isHoveringButton = false;
        const mouse = new THREE.Vector2();

        const rideStates = { carousel: false, ferris: false, teacups: false, coaster: false };
        let carouselRot, ferrisRot, cupRot, coasterCart;
        let coasterProgress = 0;
        let carouselHorses = [];
        let time = 0;

        function createBrightMaterial() {
            return new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.1, side: THREE.DoubleSide });
        }

        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 250);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 300);
            camera.rotation.order = 'YXZ';
            camera.position.set(0, 1.7, 50); 

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1; 
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 1.3); scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xfffaed, 3.0); 
            sun.position.set(50, 100, 50); sun.castShadow = true;
            sun.shadow.mapSize.set(2048,2048); sun.shadow.bias = -0.0005;
            scene.add(sun);
            const fill = new THREE.DirectionalLight(0xddeeff, 1.0); fill.position.set(-50, 30, -50); scene.add(fill);

            const sunMesh = new THREE.Mesh(new THREE.SphereGeometry(6, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffaa }));
            sunMesh.position.copy(sun.position).multiplyScalar(0.8); scene.add(sunMesh);

            buildPark();

            raycaster = new THREE.Raycaster();
            window.addEventListener('resize', onResize);
            setupControls();
            animate();
        }

        function buildPark() {
            const floorMat = new THREE.MeshStandardMaterial({ map: createGrassTex(), roughness: 1 });
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), floorMat);
            floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

            const wallMat = new THREE.MeshStandardMaterial({ map: createWallTex(), roughness: 0.9 });
            const wallGeo = new THREE.PlaneGeometry(300, 20);
            const w1 = new THREE.Mesh(wallGeo, wallMat); w1.position.set(0, 10, -150); scene.add(w1);
            const w2 = new THREE.Mesh(wallGeo, wallMat); w2.position.set(0, 10, 150); w2.rotation.y=Math.PI; scene.add(w2);
            const w3 = new THREE.Mesh(wallGeo, wallMat); w3.position.set(-150, 10, 0); w3.rotation.y=Math.PI/2; scene.add(w3);
            const w4 = new THREE.Mesh(wallGeo, wallMat); w4.position.set(150, 10, 0); w4.rotation.y=-Math.PI/2; scene.add(w4);
            colliders.push(new THREE.Box3().setFromObject(w1), new THREE.Box3().setFromObject(w2), new THREE.Box3().setFromObject(w3), new THREE.Box3().setFromObject(w4));

            const pathMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
            const path1 = new THREE.Mesh(new THREE.PlaneGeometry(12, 200), pathMat);
            path1.rotation.x = -Math.PI/2; path1.position.y = 0.05; path1.receiveShadow=true; scene.add(path1);
            const path2 = new THREE.Mesh(new THREE.PlaneGeometry(200, 12), pathMat);
            path2.rotation.x = -Math.PI/2; path2.position.y = 0.06; path2.receiveShadow=true; scene.add(path2);

            buildCarousel(0, 0);
            buildFerrisWheel(-70, 0); 
            buildTeaCups(70, 0);
            buildRollerCoaster(0, -80);
        }

        function createConsole(x, z, ry, id) {
            const group = new THREE.Group(); group.position.set(x, 0, z); group.rotation.y = ry; scene.add(group);
            const stand = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.5), new THREE.MeshStandardMaterial({color:0x333}));
            stand.position.y = 0.6; group.add(stand); colliders.push(new THREE.Box3().setFromObject(stand));
            const box = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.6, 0.8), new THREE.MeshStandardMaterial({color:0x555}));
            box.position.set(0, 1.2, 0.2); box.rotation.x = 0.5; group.add(box);
            const btn = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0x00FF00, emissive: 0x004400 }));
            btn.position.set(0, 1.5, 0.3); btn.rotation.x = 0.5; btn.userData = { isButton: true, rideId: id };
            group.add(btn); buttons.push(btn);
        }

        // 1. Carousel
        function buildCarousel(x, z) {
            const group = new THREE.Group(); group.position.set(x, 0, z); scene.add(group);
            createConsole(x, z + 15, 0, 'carousel');
            const base = new THREE.Mesh(new THREE.CylinderGeometry(10, 11, 1, 32), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            base.position.y = 0.5; base.receiveShadow = true; group.add(base);
            const center = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 10, 32), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            center.position.y = 5; group.add(center); colliders.push(new THREE.Box3().setFromObject(center));
            carouselRot = new THREE.Group(); group.add(carouselRot);
            
            const canopy = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 2.5, 32, 1, true), createBrightMaterial());
            canopy.position.y = 10; canopy.userData = { id: 'Carousel_Canopy', isInteractable: true, desc: 'é ‚æ£š' };
            carouselRot.add(canopy); interactables.push(canopy);
            const top = new THREE.Mesh(new THREE.ConeGeometry(10.5, 4, 32), new THREE.MeshStandardMaterial({ color: 0xFF6B6B }));
            top.position.y = 13; carouselRot.add(top);

            const matMane = new THREE.MeshStandardMaterial({color: 0xcc9966});

            for(let i=0; i<8; i++) {
                const angle = (i/8) * Math.PI*2; const px = Math.cos(angle) * 7; const pz = Math.sin(angle) * 7;
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 10), new THREE.MeshStandardMaterial({color:0xFFD700, metalness:0.8, roughness:0.2}));
                pole.position.set(px, 5, pz); carouselRot.add(pole);

                const horse = new THREE.Group(); 
                horse.position.set(px, 3.5, pz); 
                horse.rotation.y = -angle - Math.PI/2;
                
                const uniqueMatBody = new THREE.MeshStandardMaterial({color: 0xffffff});

                const parts = [];
                parts.push(new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 1.6, 4, 8), uniqueMatBody)); parts[0].rotation.z = Math.PI/2;
                
                const neck = new THREE.Mesh(new THREE.CapsuleGeometry(0.3, 1.2, 4, 8), uniqueMatBody); 
                neck.position.set(0.8, 0.8, 0); neck.rotation.z = -Math.PI/3; parts.push(neck);
                
                const headGroup = new THREE.Group();
                headGroup.position.set(1.3, 1.5, 0); headGroup.rotation.z = -0.2;
                const headMain = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.7), uniqueMatBody); headGroup.add(headMain);
                const snout = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.5), uniqueMatBody); snout.position.set(0.4, -0.1, 0); headGroup.add(snout);
                
                const legGeo = new THREE.CylinderGeometry(0.12, 0.1, 1.2);
                const legs = [{x:0.6, y:-0.8, z:0.25, r:-0.4}, {x:0.6, y:-0.8, z:-0.25, r:-0.4}, {x:-0.6, y:-0.8, z:0.25, r:0.3}, {x:-0.6, y:-0.8, z:-0.25, r:0.3}];
                legs.forEach(l => { const leg = new THREE.Mesh(legGeo, uniqueMatBody); leg.position.set(l.x, l.y, l.z); leg.rotation.z = l.r; parts.push(leg); });

                const mane = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.2, 0.1), matMane);
                mane.position.set(0.7, 1.0, 0); mane.rotation.z = -Math.PI/3; horse.add(mane);
                const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.2, 1), matMane);
                tail.position.set(-1.0, 0.3, 0); tail.rotation.z = Math.PI/1.5; horse.add(tail);

                parts.forEach(p => { p.userData = { id: `Carousel_Horse_${i}`, isInteractable: true, desc: 'æœ¨é¦¬' }; interactables.push(p); horse.add(p); });
                headMain.userData = { id: `Carousel_Horse_${i}`, isInteractable: true, desc: 'æœ¨é¦¬' }; interactables.push(headMain);
                snout.userData = { id: `Carousel_Horse_${i}`, isInteractable: true, desc: 'æœ¨é¦¬' }; interactables.push(snout);
                horse.add(headGroup);

                carouselRot.add(horse);
                carouselHorses.push(horse);
            }
        }

        // 2. Ferris Wheel
        function buildFerrisWheel(x, z) {
            const group = new THREE.Group(); group.position.set(x, -2, z); group.rotation.y = Math.PI / 4; scene.add(group);
            const cx = x + 25 * Math.sin(Math.PI/4); const cz = z + 25 * Math.cos(Math.PI/4);
            createConsole(cx, cz, Math.PI/4 + Math.PI, 'ferris');
            const trussMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const l1 = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 32), trussMat); l1.position.set(0, 15, 8); l1.rotation.x = -0.5;
            const l2 = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 32), trussMat); l2.position.set(0, 15, -8); l2.rotation.x = 0.5;
            const legG = new THREE.Group(); legG.add(l1); legG.add(l2);
            const legG2 = legG.clone(); legG.position.x = -2; legG2.position.x = 2; group.add(legG); group.add(legG2);
            colliders.push(new THREE.Box3().setFromObject(l1));
            ferrisRot = new THREE.Group(); ferrisRot.position.y = 28; group.add(ferrisRot);
            const rimGeo = new THREE.TorusGeometry(20, 0.5, 16, 64); const rimMat = new THREE.MeshStandardMaterial({color: 0xFF4081});
            const r1 = new THREE.Mesh(rimGeo, rimMat); r1.position.x = 1.5; r1.rotation.y = Math.PI/2; ferrisRot.add(r1);
            const r2 = new THREE.Mesh(rimGeo, rimMat); r2.position.x = -1.5; r2.rotation.y = Math.PI/2; ferrisRot.add(r2);
            for(let i=0; i<12; i++) {
                const a = (i/12)*Math.PI*2;
                const spk = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 20), trussMat); spk.position.set(0, Math.sin(a)*10, Math.cos(a)*10); spk.rotation.x = -a; ferrisRot.add(spk);
                const pivot = new THREE.Group(); pivot.position.set(0, Math.sin(a)*20, Math.cos(a)*20); ferrisRot.add(pivot);
                const cab = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), createBrightMaterial());
                cab.userData = { id: `Ferris_Cab_${i}`, isInteractable: true, desc: 'è»Šå»‚' }; pivot.add(cab); interactables.push(cab); pivot.userData.isCabinPivot = true;
            }
        }

        // 3. Tea Cups
        function buildTeaCups(x, z) {
            const group = new THREE.Group(); group.position.set(x, 0, z); scene.add(group);
            createConsole(x - 15, z, Math.PI/2, 'teacups');
            const base = new THREE.Mesh(new THREE.CylinderGeometry(14, 15, 1, 64), new THREE.MeshStandardMaterial({ color: 0x9C27B0 }));
            base.position.y = 0.5; base.receiveShadow=true; group.add(base);
            const teapotG = new THREE.Group(); teapotG.position.y = 4; group.add(teapotG);
            const brightMat = createBrightMaterial(); 
            const pot = new THREE.Mesh(new THREE.SphereGeometry(3.5, 32, 32), brightMat); pot.scale.y = 0.8; 
            pot.userData = { id: 'TeaPot_Center', isInteractable: true, desc: 'å¤§èŒ¶å£º' }; interactables.push(pot); teapotG.add(pot); colliders.push(new THREE.Box3().setFromObject(pot));
            const spout = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 3), brightMat); spout.position.set(3.2, 1, 0); spout.rotation.z = -Math.PI/3; teapotG.add(spout);
            const hdl = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.3, 16, 32, Math.PI), brightMat); hdl.position.set(-2.8, 0, 0); hdl.rotation.z = -Math.PI/2; hdl.rotation.y = Math.PI; teapotG.add(hdl);
            const lid = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.2, 0.5), new THREE.MeshStandardMaterial({color:0x9C27B0})); lid.position.y = 2.5; teapotG.add(lid);
            cupRot = new THREE.Group(); group.add(cupRot);
            for(let i=0; i<4; i++) {
                const a = (i/4) * Math.PI * 2; const cupG = new THREE.Group(); cupG.position.set(Math.cos(a)*8, 1, Math.sin(a)*8); cupRot.add(cupG);
                const s = new THREE.Mesh(new THREE.CylinderGeometry(3.5, 3.5, 0.2, 32), new THREE.MeshStandardMaterial({color: 0xFFD54F})); cupG.add(s);
                const cup = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 1.8, 2.5, 32), createBrightMaterial()); cup.position.y = 1.3;
                const ch = new THREE.Mesh(new THREE.TorusGeometry(1, 0.2, 8, 16), createBrightMaterial()); ch.position.set(2.5, 0, 0); ch.rotation.z = Math.PI/2; cup.add(ch);
                cup.userData = { id: `TeaCup_${i}`, isInteractable: true, spinSpeed: (Math.random()+1)*0.05, desc: 'å’–å•¡æ¯' }; cupG.add(cup); interactables.push(cup);
            }
        }

        // 4. Roller Coaster
        function buildRollerCoaster(x, z) {
            const group = new THREE.Group(); group.position.set(x, 0, z); scene.add(group);
            createConsole(x, z + 25, 0, 'coaster');
            const pts = [new THREE.Vector3(-40, 5, 0), new THREE.Vector3(-30, 30, 0), new THREE.Vector3(0, 20, 20), new THREE.Vector3(30, 40, 0), new THREE.Vector3(40, 15, -10), new THREE.Vector3(0, 10, -20), new THREE.Vector3(-40, 5, 0)];
            const curve = new THREE.CatmullRomCurve3(pts, true);
            const track = new THREE.Mesh(new THREE.TubeGeometry(curve, 100, 0.5, 8, true), new THREE.MeshStandardMaterial({ color: 0xFF0000 })); group.add(track);
            curve.getPoints(15).forEach(p => { if(p.y>3) { const s = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, p.y), new THREE.MeshStandardMaterial({color:0x444})); s.position.set(p.x, p.y/2, p.z); group.add(s); }});

            coasterCart = new THREE.Group(); coasterCart.userData = { path: curve }; group.add(coasterCart);
            const carGroup = new THREE.Group();
            
            const chassis = new THREE.Mesh(new THREE.BoxGeometry(4.5, 0.5, 7.5), new THREE.MeshStandardMaterial({color:0x222}));
            chassis.position.y = 0.25; carGroup.add(chassis);

            const bodyGeo = new THREE.BoxGeometry(4.2, 2.5, 7); 
            const bodyMat = createBrightMaterial();
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.75; 
            body.userData = { id: 'Coaster_Body', isInteractable: true, desc: 'è»Šèº«' }; 
            interactables.push(body); carGroup.add(body);

            const nose = new THREE.Mesh(new THREE.CylinderGeometry(2.1, 2.1, 4.2, 32, 1, false, 0, Math.PI), createBrightMaterial());
            nose.rotation.z = Math.PI/2; nose.position.set(0, 1.75, 3.5); carGroup.add(nose);

            const seat = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 5), new THREE.MeshStandardMaterial({color: 0x888}));
            seat.position.set(0, 2, 0); carGroup.add(seat);

            const railGeo = new THREE.CylinderGeometry(0.1, 0.1, 5);
            const railMat = new THREE.MeshStandardMaterial({color: 0xcccccc, metalness: 0.8, roughness: 0.2});
            const rL = new THREE.Mesh(railGeo, railMat); rL.rotation.x=Math.PI/2; rL.position.set(1.8, 3.2, 0); carGroup.add(rL);
            const rR = new THREE.Mesh(railGeo, railMat); rR.rotation.x=Math.PI/2; rR.position.set(-1.8, 3.2, 0); carGroup.add(rR);

            const wGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4); const wMat = new THREE.MeshStandardMaterial({color:0x111});
            const poses = [[2.3, 0, 2.5], [-2.3, 0, 2.5], [2.3, 0, -2.5], [-2.3, 0, -2.5]];
            poses.forEach(p => { const w = new THREE.Mesh(wGeo, wMat); w.rotation.z=Math.PI/2; w.position.set(...p); carGroup.add(w); });

            coasterCart.add(carGroup);

            const board = new THREE.Mesh(new THREE.BoxGeometry(16, 9, 0.5), createBrightMaterial());
            board.position.set(0, 8, 20); board.userData = { id: 'Coaster_Sign', isInteractable: true, desc: 'æ‹›ç‰Œ' };
            group.add(board); interactables.push(board);
            const p1 = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,10), new THREE.MeshStandardMaterial({color:0x444})); p1.position.set(-7,5,20); group.add(p1);
            const p2 = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,10), new THREE.MeshStandardMaterial({color:0x444})); p2.position.set(7,5,20); group.add(p2);
        }

        function toggleRide(id) {
            rideStates[id] = !rideStates[id];
            const btn = buttons.find(b => b.userData.rideId === id);
            if(btn) btn.material.color.setHex(rideStates[id] ? 0xFF0000 : 0x00FF00);
        }

        uploadInput.addEventListener('change', e => {
            if(!e.target.files[0]||!targetObj) return;
            const r = new FileReader();
            r.onload = ev => {
                const img = new Image(); img.onload = () => {
                    const c = document.createElement('canvas'); const ctx=c.getContext('2d');
                    let w=img.width, h=img.height, m=1024;
                    if(w>m||h>m){const s=Math.min(m/w,m/h);w*=s;h*=s;}
                    c.width=w;c.height=h; ctx.drawImage(img,0,0,w,h);
                    
                    new THREE.TextureLoader().load(c.toDataURL('image/jpeg',0.9), t => {
                        t.colorSpace = THREE.SRGBColorSpace;
                        if(targetObj.geometry.type !== 'PlaneGeometry') t.flipY = true;
                        
                        targetObj.material.map = t;
                        targetObj.material.needsUpdate = true;
                        targetObj.material.color.setHex(0xffffff);
                        
                        if(db) setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'objects', `tex_${targetObj.userData.id}`), {img:c.toDataURL('image/jpeg',0.8), t:serverTimestamp()}).catch(()=>{});
                        alert('æ›´æ›æˆåŠŸï¼');
                    });
                }; img.src = ev.target.result;
            }; r.readAsDataURL(e.target.files[0]); uploadInput.value="";
        });

        function startNetworkSync() {
            if(!db) return;
            setInterval(() => {
                if(!currentUser) return;
                const p = camera.position;
                setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'objects', `p_${currentUser.uid}`), 
                    {x:p.x, y:p.y, z:p.z, ry:camera.rotation.y, c:'#'+myColor, t:Date.now()}).catch(()=>{});
            }, 100);
            
            onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', 'objects'), s => {
                s.docChanges().forEach(c => {
                    const d=c.doc.data(); const id=c.doc.id;
                    if(id.startsWith('tex_')) updateTexture(id.replace('tex_',''), d.img);
                });
            });
        }

        function updateTexture(objId, img) {
            const obj = interactables.find(o => o.userData.id === objId);
            if(obj) {
                new THREE.TextureLoader().load(img, t=>{ 
                    t.colorSpace = THREE.SRGBColorSpace;
                    if(obj.geometry.type!=='PlaneGeometry') t.flipY=true;
                    obj.material.map=t; obj.material.needsUpdate=true; 
                });
            }
        }

        function setupControls() {
            document.addEventListener('keydown', e=>{ const k=e.key.toLowerCase(); if(['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'].includes(k)) keys[k]=true; });
            document.addEventListener('keyup', e=>{ const k=e.key.toLowerCase(); if(['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'].includes(k)) keys[k]=false; });
            
            document.addEventListener('mousedown', () => { isDragging = true; });
            document.addEventListener('mouseup', () => { isDragging = false; });
            
            document.addEventListener('mousemove', e => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                if(isDragging && !isMobile()) {
                    rotateCam(e.movementX, e.movementY);
                }
            });

            // [é—œéµ] åƒ…æŒ‰éˆ•è² è²¬é»æ“Šäº’å‹•ï¼Œé€™è£¡ç§»é™¤å…¨åŸŸé»æ“Šäº‹ä»¶
            // æŒ‰éˆ•çš„é»æ“Šç›£è½å¯«åœ¨ä¸‹é¢

            // [æ–°å¢] æŒ‰éˆ•çš„ Hover ç‹€æ…‹ç›£è½
            btnEl.addEventListener('mouseenter', () => isHoveringButton = true);
            btnEl.addEventListener('mouseleave', () => isHoveringButton = false);
            
            // [æ–°å¢] æŒ‰éˆ•é»æ“Šè§¸ç™¼åŠŸèƒ½
            btnEl.addEventListener('click', (e) => {
                e.stopPropagation(); // é˜²æ­¢å†’æ³¡
                if(targetObj) {
                    if(targetObj.userData.isButton) toggleRide(targetObj.userData.rideId);
                    else if(targetObj.userData.isInteractable) uploadInput.click();
                }
            });

            joystickZone.addEventListener('touchstart', e=>{joystickActive=true; updateJoy(e.touches[0]);}, {passive:false});
            joystickZone.addEventListener('touchmove', e=>{if(joystickActive) updateJoy(e.touches[0]); e.preventDefault();}, {passive:false});
            joystickZone.addEventListener('touchend', ()=>{joystickActive=false; joystickKnob.style.transform=`translate(-50%,-50%)`; moveVector.set(0,0,0);});
            lookZone.addEventListener('touchstart', e=>{lookActive=true; lastLookX=e.touches[0].clientX; lastLookY=e.touches[0].clientY;}, {passive:false});
            lookZone.addEventListener('touchmove', e=>{
                if(lookActive) {
                    const t = e.touches[0]; rotateCam(t.clientX-lastLookX, t.clientY-lastLookY); lastLookX=t.clientX; lastLookY=t.clientY;
                } e.preventDefault();
            }, {passive:false});
            lookZone.addEventListener('touchend', ()=>lookActive=false);
        }

        function updateJoy(t) {
            const r = joystickZone.getBoundingClientRect();
            const dx = t.clientX-(r.left+r.width/2); const dy = t.clientY-(r.top+r.height/2);
            const d = Math.sqrt(dx*dx+dy*dy); const f = d>40 ? 40/d : 1;
            joystickKnob.style.transform = `translate(calc(-50% + ${dx*f}px), calc(-50% + ${dy*f}px))`;
            moveVector.x=(dx*f)/40; moveVector.z=(dy*f)/40;
        }
        function rotateCam(dx, dy) {
            lookEuler.setFromQuaternion(camera.quaternion);
            lookEuler.y -= dx*0.0025; lookEuler.x -= dy*0.0025;
            lookEuler.x = Math.max(-1.4, Math.min(1.4, lookEuler.x));
            camera.quaternion.setFromEuler(lookEuler);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isRunning) return;

            time += 0.02;

            if(rideStates.carousel && carouselRot) {
                carouselRot.rotation.y -= 0.01;
                carouselHorses.forEach((horse, i) => {
                    const yOffset = Math.sin(time + i * 0.8) * 1.2; 
                    horse.position.y = 3.5 + yOffset;
                });
            }

            if(rideStates.ferris && ferrisRot) {
                ferrisRot.rotation.x -= 0.005; 
                ferrisRot.children.forEach(c => { if(c.userData.isCabinPivot) c.rotation.x += 0.005; });
            }
            if(rideStates.teacups && cupRot) {
                cupRot.rotation.y -= 0.015;
                cupRot.children.forEach(c => {
                    const cupMesh = c.children.find(m => m.userData.spinSpeed);
                    if(cupMesh) cupMesh.rotation.y += cupMesh.userData.spinSpeed;
                });
            }
            if(rideStates.coaster && coasterCart) {
                coasterProgress += 0.002; if(coasterProgress > 1) coasterProgress = 0;
                const path = coasterCart.userData.path;
                const pos = path.getPointAt(coasterProgress);
                const tangent = path.getTangentAt(coasterProgress);
                coasterCart.position.copy(pos); coasterCart.lookAt(pos.clone().add(tangent));
            }

            if(!joystickActive) {
                moveVector.set(0,0,0);
                if(keys.w || keys.arrowup) moveVector.z = -1;
                if(keys.s || keys.arrowdown) moveVector.z = 1;
                if(keys.a || keys.arrowleft) moveVector.x = -1;
                if(keys.d || keys.arrowright) moveVector.x = 1;
            }

            if(moveVector.lengthSq()>0) {
                const s = 0.4;
                const f = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); f.y=0; f.normalize();
                const r = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); r.y=0; r.normalize();
                const next = camera.position.clone().addScaledVector(f, -moveVector.z*s).addScaledVector(r, moveVector.x*s);
                let hit=false; for(let c of colliders) if(new THREE.Box3().setFromCenterAndSize(next, new THREE.Vector3(1,2,1)).intersectsBox(c)) { hit=true; break; }
                if(!hit) camera.position.copy(next);
            }

            if(isMobile()) raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            else raycaster.setFromCamera(mouse, camera);

            const hits = raycaster.intersectObjects([...interactables, ...buttons]);
            
            // æ¯æ¬¡é‡æ–°æ¸²æŸ“å‰å…ˆé‚„åŸæ‰€æœ‰ç‰©ä»¶çš„ emissive
            interactables.forEach(o => { if(o.material.emissive) o.material.emissive.setHex(0x000000); });
            buttons.forEach(b => { b.material.emissive.setHex(rideStates[b.userData.rideId] ? 0x440000 : 0x004400); });

            // [é—œéµé‚è¼¯]
            // å¦‚æœå°„ç·šæœ‰æ‰“åˆ°æ±è¥¿ï¼Œæ›´æ–° targetObj
            // å¦‚æœå°„ç·šæ²’æ‰“åˆ°æ±è¥¿ï¼Œä½†æ»‘é¼ åœ¨æŒ‰éˆ•ä¸Š (isHoveringButton)ï¼Œä¿æŒ targetObj ä¸è®Š (é˜²æŠ–)
            let hitObj = null;
            if(hits.length>0 && hits[0].distance<30) {
                hitObj = hits[0].object;
            }

            if (hitObj) {
                // æœ‰æ‰“åˆ°æ±è¥¿ -> æ›´æ–°ç›®æ¨™
                targetObj = hitObj;
            } else if (!isHoveringButton) {
                // æ²’æ‰“åˆ°æ±è¥¿ ä¸” æ²’åœ¨æŒ‰éˆ•ä¸Š -> æ¸…é™¤ç›®æ¨™
                targetObj = null;
            }
            // å¦‚æœ æ²’æ‰“åˆ°æ±è¥¿ ä½† åœ¨æŒ‰éˆ•ä¸Š -> targetObj ä¿æŒåŸæœ¬çš„ (æ‰€ä»¥ä¸ç”¨å¯« else)

            if (targetObj) {
                // è¦–è¦ºå›é¥‹ï¼šè®“ç‰©ä»¶ç™¼å…‰
                if (targetObj.userData.isInteractable) {
                    if (targetObj.material.emissive) targetObj.material.emissive.setHex(0x222222);
                }

                // è¨ˆç®—ä¸¦ç§»å‹•æŒ‰éˆ•ä½ç½®
                // ç‚ºäº†é¿å…æŒ‰éˆ•åœ¨ç‰©ä»¶ç§»å‹•æ™‚è·Ÿä¸Ÿï¼Œæˆ‘å€‘é‡æ–°è¨ˆç®—ä¸€æ¬¡ targetObj çš„ä½ç½®
                // å–å¾—ç‰©ä»¶çš„ä¸–ç•Œåº§æ¨™
                const worldPos = new THREE.Vector3();
                targetObj.getWorldPosition(worldPos);
                worldPos.project(camera); // è½‰ç‚º NDC (-1~1)

                const x = (worldPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(worldPos.y * 0.5) + 0.5) * window.innerHeight;

                btnEl.style.display = 'block';
                btnEl.style.left = `${x}px`;
                btnEl.style.top = `${y}px`;

                if(targetObj.userData.isButton) {
                    const state = rideStates[targetObj.userData.rideId];
                    btnEl.innerText = state ? `ğŸ”´ åœæ­¢` : `ğŸŸ¢ å•Ÿå‹•`;
                    btnEl.style.background = state ? '#ff4444' : '#44ff44';
                    btnEl.style.color = '#fff';
                } else if(targetObj.userData.isInteractable) {
                    btnEl.innerText = `ğŸ–¼ï¸ æ›´æ›${targetObj.userData.desc}`;
                    btnEl.style.background = '#FFD700';
                    btnEl.style.color = '#333';
                }
            } else {
                btnEl.style.display = 'none';
            }

            renderer.render(scene, camera);
        }
        function onResize() {
            camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight);
        }
    </script>
</body>
</html>
